//Method 1
 
class Solution {
    public int findDuplicate(int[] arr) {
        int repeating = -1;
        for (int i = 0; i < arr.length; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[i] == arr[j]) {
                    repeating = arr[i];
                    break;
                }
            }
        }
        return repeating;
    }
}


//Method 2

class Solution {
    public int findDuplicate(int[] arr) {
        Arrays.sort(arr);
        int repeating = -1;

        for (int i = 1; i < arr.length; i++) {
            if (arr[i] == arr[i - 1]) {
                repeating = arr[i];
                break;
            }
        }

        return repeating;
    }
}


//Method 3

class Solution {
    public int findDuplicate(int[] arr) {
        Set<Integer> unique = new HashSet<>();
        int repeated = -1;

        for (int num : arr) {
            if (unique.contains(num)) {
                repeated = num;
                break;
            }
            unique.add(num);
        }

        return repeated;
    }
}


//Method 4

class Solution {
    public int findDuplicate(int[] arr) {
        int repeating = -1;
        boolean[] visited = new boolean[arr.length];

        for (int num : arr) {
            if (!visited[num]) {
                visited[num] = true;
            } else {
                repeating = num;
                break;
            }
        }

        return repeating;
    }
}


//Method 5

class Solution {
    public int findDuplicate(int[] arr) {
        int repeated = -1;
        for (int num : arr) {
            int value = Math.abs(num);

            if (arr[value] < 0) {
                repeated = value;
                break;
            }

            arr[value] *= -1;
        }

        return repeated;
    }
}


//Method 6

class Solution {
    public int findDuplicate(int[] arr) {
        int n = arr.length;
        long arrSum = 0, uniqueSum = ((long) (n - 1) * ((n - 1) + 1)) / 2;// sum of first (n-1) Natural Numbers

        for (int num : arr) {
            arrSum += num;
        }

        return (int) (arrSum - uniqueSum);
    }
}


//Method 7

class Solution {
    public int findDuplicate(int[] arr) {
        int xor1 = 0, xor2 = arr[0];

        for (int num = 1; num <= (arr.length - 1); num++) {
            xor1 = xor1 ^ num;
        }

        for (int i = 1; i < arr.length; i++) {
            xor2 = xor2 ^ arr[i];
        }

        return xor1 ^ xor2;
    }
}


//Method 8 : (Cycle Sort)

class Solution {
    public int findDuplicate(int[] arr) {
        int i = 0;
        while (i < arr.length) {
            int correctIndex = arr[i] - 1;

            if (arr[i] == arr[correctIndex]) {
                i++;
            } else { // if arr[i] is not at its correct index
                swap(arr, i, correctIndex);
            }
        }
        // After rearranging, every value from 1 to n−1 settles at its correct index, and the repeated number ultimately lands at the last index.
        return arr[arr.length - 1];
    }

    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

/*
 Ex :

 int[] arr={1,3,2,4,2,2};
 
 Iteration 1 :(i==0)
 arr[0]=1;
 correctIndexOf 1 in a sorted Array =0;
 clearly 1 is at its Correct index i.e 0
 so i++;
 
 Iteration 2 :(i==1)
 arr[1]=3;
 correctIndexOf 3 in a sorted Array =2;
 clearly 3 is not at its Correct index
 so Swap(arr[1],arr[2]);
 
 Resultant Array :
 arr={1,2,3,4,2,2};
 
 Now 3 is at its Correct Index.i.e 2
 
 
 Iteration 3 :(i==1)
 arr[1]=2;
 correctIndexOf 2 in a sorted Array =1;
 clearly 2 is at its Correct index i.e 1
 so i++
 
 
 Iteration 4 :(i==2)
 arr[2]=3;
 correctIndexOf 3 in a sorted Array = 2;
 clearly 3 is at its Correct index i.e 2
 so i++;
 
 
 Iteration 5 :(i==3)
 arr[3]=4;
 correctIndexOf 4 in a sorted Array = 3;
 clearly 4 is at its Correct index i.e 3
 so i++;
 
 
 Iteration 6 :(i==4)
 arr[4]=2;
 correctIndexOf 2 in a sorted Array = 1;
 clearly 2 is at its Correct index
 so i++;


 Iteration 7 :(i==5)
 arr[5]=2;
 correctIndexOf 2 in a sorted Array = 1;
 clearly 2 is at its Correct index.
 so i++;
 
 //Loop terminates
 
 final Arrray:
 int[] arr=arr={1,2,3,4,2,2};
 
 now print the element which is not at its correct index i.e arr[i]!=i+1
 Thus the Duplicate number is 2(at index 4 or 5).
  
  
 Optimisation :
 In other words all the distinct elements will occupy their correct index while remaining duplicate instances will occupy the remaining indexes,
 so this gurantees that last index will always carry duplicate number.
*/


//Method 9 (Binary Search on answer)

class Solution {
    public int findDuplicate(int[] arr) {
        int low = 1, high = arr.length - 1; // coz array consists of Elements in range [1,n-1] while size of array is n

        while (low < high) {
            int mid = low + (high - low) / 2;
            int count = 0;

            for (int val : arr) {
                if (val <= mid) {
                    count++;
                }
            }

            if (count > mid) {// Duplicate would be present in the range [low ,mid](both inclusive) so search space [low,mid]
                high = mid;
            } else { // if(count<=mid) => Duplicate is not present in the range [low ,mid](both inclusive) so search space [mid+1,high]
                low = mid + 1;
            }
        }

        return low; // or return high;
    }
}

/*
 Binary-search-on-answer using the Pigeonhole Principle.

 For a chosen mid, let:
   count = number of elements in the array with value <= mid

 Interpretation reveals three possible cases:

 1) count > mid
    - Range [1..mid] can contain at most mid distinct values.
    - If more than mid elements fall in this range, a pigeonhole
      violation occurs.
    - Hence, a duplicate must exist in [1..mid].
    - Action: high = mid

    Example:
    arr = {5,5,5,2,3,4,6,7,8,9}, mid = 5
    count(<=5) = 6 > 5 → duplicate in [1..5]

 2) count < mid
    - Fewer elements than available slots.
    - This indicates missing numbers in [1..mid], not duplication.
    - Hence, the duplicate must be in [mid+1..high].
    - Action: low = mid + 1

    Example:
    arr = {1,4,5,6,6,6,6,7,8,9}, mid = 5
    count(<=5) = 3 < 5 → duplicate in [6..9]

 3) count == mid
    - Exactly mid elements occupy mid slots.
    - No pigeonhole violation; all values could be distinct.
    - Hence, duplicate must still lie in [mid+1..high].
    - Action: low = mid + 1

    Example:
    arr = {1,2,3,4,5,6,6,6,6,9}, mid = 5
    count(<=5) = 5 == 5 → duplicate in [6..9]
*/



//Method 10

class Solution {
    public int findDuplicate(int[] arr) {
        // The slow pointer moves 1 step while the fast pointer moves 2 steps at a time.
        // If they meet, then there is a cycle. The starting point of that cycle is the repeating number.
        
        int slowPointer = arr[0];
        int fastPointer = arr[arr[0]];
        
        // CYCLE DETECTION using Floyd's Cycle Detection algorithm
        while (slowPointer != fastPointer) {
            slowPointer = arr[slowPointer];
            fastPointer = arr[arr[fastPointer]];
        }
        
        // DETECTING THE STARTING POINT OF THE CYCLE
        // Reset one pointer to the beginning and move both pointers one step at a time.
        // They will meet at the starting point of the cycle, which is the repeating number.
        fastPointer = 0; // or slowPointer = 0
        while (slowPointer != fastPointer) {
            slowPointer = arr[slowPointer];
            fastPointer = arr[fastPointer];
        }
        
        return slowPointer; // both pointers meet at the starting point of the cycle
    }
}

/*
    let’s take an example and dry run on it to understand.

       0   1   2   3   4   5   6   7   8   9
     | 2 | 5 | 9 | 6 | 9 | 3 | 8 | 9 | 7 | 1 |
  
      
       2 -- 9 -- 1 -- 5
            |         |
            |         3
            |         |
            7 -- 8 -- 6

  Initially, we have 2, then we go to the second index, we have 9, then we go to the 9th index, 
  we have 1, then we go to the 1st index, we again have 5, 
  then we go to the 5th index, we have 3, then we go to the 3rd index, 
  we get 6, then we go to the 6th index, we get 8, then we go to the 8th index, 
  we get 7, then we go to the 7th index and we get 9 and here cycle is formed.
*/
