//Method 1

class Solution {
    public int findDuplicate(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[i] == arr[j]) {
                    return arr[i];
                }
            }
        }
        return -1; // This case won’t ever occur based on the problem’s guarantees
    }
}


//Method 2

class Solution {
    public int findDuplicate(int[] arr) {
        Arrays.sort(arr);

        for (int i = 1; i < arr.length; i++) {
            if (arr[i] == arr[i - 1]) {
                return arr[i];
            }
        }

        return -1;
    }
}


//Method 3

class Solution {
    public int findDuplicate(int[] arr) {
        Set<Integer> unique = new HashSet<>();

        for (int num : arr) {
            if (unique.contains(num)) {
                return num;
            }
            unique.add(num);
        }

        return -1;
    }
}


//Method 4 

class Solution {
    public int findDuplicate(int[] arr) {
        boolean[] visited = new boolean[arr.length];

        for (int num : arr) {
            if (visited[num]) {
                return num;
            }

            visited[num] = true;
        }

        return -1;
    }
}


//Method 5

class Solution {
    public int findDuplicate(int[] arr) {
        for (int num : arr) {
            int value = Math.abs(num);

            if (arr[value] < 0) {
                return value;
            }

            arr[value] *= -1;
        }

        return -1;
    }
}


//Method 6 (Cyclic Sort)

class Solution {
    public int findDuplicate(int[] arr) {
        int i = 0;

        while (i < arr.length) {
            int correctIndex = arr[i] - 1;
            if (arr[correctIndex] == arr[i]) {
                i++;
            } else { // if arr[i] is not at its correct index
                swap(arr, i, correctIndex);
            }
        }

        return arr[arr.length - 1];
    }

    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}



//Method 8 (Binary search on answer)

class Solution {
    public int findDuplicate(int[] arr) {
        int low = 1, high = arr.length - 1; // coz array consists of Elements in range [1,n] while size of array is n+1

        while (low < high) {
            int mid = low + (high - low) / 2;
            int count = 0;

            for (int val : arr) {
                if (val <= mid) {
                    count++;
                }
            }

            if (count > mid) {// Duplicate would be present in the range [low ,mid](both inclusive) so search space [low,mid]
                high = mid;
            } else { // if(count<=mid) => Duplicate is not present in the range [low ,mid](both inclusive) so search space [mid+1,high]
                low = mid + 1;
            }
        }

        return low; // or return high;
    }
}

/*
 Binary-search-on-answer using the Pigeonhole Principle.

 For a chosen mid, let:
   count = number of elements in the array with value <= mid

 Interpretation reveals three possible cases:

 1) count > mid
    - Range [1..mid] can contain at most mid distinct values.
    - If more than mid elements fall in this range, a pigeonhole
      violation occurs.
    - Hence, a duplicate must exist in [1..mid].
    - Action: high = mid

    Example:
    arr = {5,5,5,2,3,4,6,7,8,9}, mid = 5
    count(<=5) = 6 > 5 → duplicate in [1..5]

 2) count < mid
    - Fewer elements than available slots.
    - This indicates missing numbers in [1..mid], not duplication.
    - Hence, the duplicate must be in [mid+1..high].
    - Action: low = mid + 1

    Example:
    arr = {1,4,5,6,6,6,6,7,8,9}, mid = 5
    count(<=5) = 3 < 5 → duplicate in [6..9]

 3) count == mid
    - Exactly mid elements occupy mid slots.
    - No pigeonhole violation; all values could be distinct.
    - Hence, duplicate must still lie in [mid+1..high].
    - Action: low = mid + 1

    Example:
    arr = {1,2,3,4,5,6,6,6,6,9}, mid = 5
    count(<=5) = 5 == 5 → duplicate in [6..9]

 Summary:
   if (count > mid)  → search left half
   else              → search right half

 Only count > mid forces the search to the left.
*/



//Method 9 (Floyd Cycle Detection Algorithm) (T.C = O(n) , S.C = O(1) and Doesnot Modifies the Array)

class Solution {
    public int findDuplicate(int[] arr) {
        // slow moves 1 step at a time, fast moves 2 steps. If they meet, it confirms the presence of a cycle.
        int slow = arr[0];
        int fast = arr[arr[0]];
        
        // PHASE 1: Detect the cycle using Floyd's algorithm
        while (slow != fast) {
            slow = arr[slow];
            fast = arr[arr[fast]];
        }
        
        // PHASE 2: Find the starting point of the cycle.
        // Move slow to the beginning (index 0) and advance both slow and fast one step at a time. Their meeting point is the duplicate number.
        fast = 0;
        while (slow != fast) {
            slow = arr[slow];
            fast = arr[fast];
        }
        
        return slow; // both meet at the repeating element
    }
}

/*
    This algorithm relies on the pigeonhole principle and the problem’s strict constraints:

        - The array length is (n + 1)
        - Every value is in the range [1..n]

    Since there are n possible values but (n + 1) positions filled with values from 1..n,
    at least one value MUST appear more than once — duplication is mathematically guaranteed.
    This guarantee is crucial because Floyd’s cycle detection works only if a cycle exists.

    Two different indices have same value → a repeated value causes two different indices to point to the same spot  → loop.

    Without these constraints:
        - No duplicate may exist → no cycle → slow and fast would never meet,
          causing an infinite loop.
        - A value outside the range [1..n] could also lead to out-of-bounds indexing.
*/
