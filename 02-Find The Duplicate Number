//Method 1

class Solution {
    public int findDuplicate(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[i] == arr[j]) {
                    return arr[i];
                }
            }
        }
        return -1; // This case won’t ever occur based on the problem’s guarantees
    }
}


//Method 2

class Solution {
    public int findDuplicate(int[] arr) {
        Arrays.sort(arr);

        for (int i = 1; i < arr.length; i++) {
            if (arr[i] == arr[i - 1]) {
                return arr[i];
            }
        }

        return -1;
    }
}


//Method 3

class Solution {
    public int findDuplicate(int[] arr) {
        Set<Integer> unique = new HashSet<>();

        for (int num : arr) {
            if (unique.contains(num)) {
                return num;
            }
            unique.add(num);
        }

        return -1;
    }
}


//Method 4 

class Solution {
    public int findDuplicate(int[] arr) {
        boolean[] visited = new boolean[arr.length];

        for (int num : arr) {
            if (visited[num]) {
                return num;
            }

            visited[num] = true;
        }

        return -1;
    }
}


//Method 5

class Solution {
    public int findDuplicate(int[] arr) {
        for (int num : arr) {
            int value = Math.abs(num);

            if (arr[value] < 0) {
                return value;
            }

            arr[value] *= -1;
        }

        return -1;
    }
}


//Method 6 (Cyclic Sort)

class Solution {
    public int findDuplicate(int[] arr) {
        int i = 0;

        while (i < arr.length) {
            int correctIndex = arr[i] - 1;
            if (arr[correctIndex] == arr[i]) {
                i++;
            } else { // if arr[i] is not at its correct index
                swap(arr, i, correctIndex);
            }
        }

        return arr[arr.length - 1];
    }

    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}


//Method 8 (Binary search on answer)

class Solution {
    public int findDuplicate(int[] arr) {
        int low = 1, high = arr.length - 1; // coz array consists of Elements in range [1,n] while size of array is n+1

        while (low < high) {
            int mid = low + (high - low) / 2;
            int count = 0;

            for (int val : arr) {
                if (val <= mid) {
                    count++;
                }
            }

            if (count > mid) {// Duplicate would be present in the range [low ,mid](both inclusive) so search space [low,mid]
                high = mid;
            } else { // if(count<=mid) => Duplicate is not present in the range [low ,mid](both inclusive) so search space [mid+1,high]
                low = mid + 1;
            }
        }

        return low; // or return high;
    }
}

/*
  int[] arr={1,3,4,2,2};
  

  Iteration 1:(low=1,high=4)
  
  mid=(1+4)/2=2;
  (count of numbers in array) <= mid(i.e 2) =3.
  
  (Had there been no duplicates in the array then "count of numbers in array <=2" would have been <= 2 but here exists more than 2 numbers in the array which are <=2 which means there lies/Exists a duplicate in the range (1,2)i.e(low,mid)(both inclusive) so our search space will be (1,2) i.e (low,mid))
  thus high=mid i.e high =2;
  i.e low=1 and high=2
  
  
  Iteration 2:(low=1 and high=2)
  
  mid=(1+2)/2=1;
  (count of numbers in array) <= mid(i.e 1) =1.
  
  (Had there been duplicates in the array then "count of numbers in array<=1" would have been more than 1,but here exists only 1 num. less <= 1 which means there Exists  no duplicate in the range (1,1) i.e(low,mid)(both inclusive) so our search space will be [2,2] i.e[mid+1,high]).
  
  thus low=mid+1 i.e low=2;
  
  i.e low=2 and high=2.
  
  
  Iteration 3:(low=2 and high=2)
  
   mid=(2+2)/2=2;
  (count of numbers in array) <= mid(i.e 2) =3
  
  
  (Had there been no duplicates in the array  then "count of numbers in array <=2" would have been <= 2 but here exists more than 2 numbers in the array which are <=2 which means there lies/Exists a duplicate in the range (2,2)i.e (low,mid)(both inclusive) so our search space will be (2,2)i.e (low,mid))
  thus high=mid i.e high =2;
  i.e low=2 and high=2.
  
  //Loop Terminates
  
  return low or high
  
*/


//Method 9 (Floyd Cycle Detection Algorithm) (T.C = O(n) , S.C = O(1) and Doesnot Modifies the Array)

class Solution {
    public int findDuplicate(int[] arr) {
        // slow moves 1 step at a time, fast moves 2 steps. If they meet, it confirms the presence of a cycle.
        int slow = arr[0];
        int fast = arr[arr[0]];
        
        // PHASE 1: Detect the cycle using Floyd's algorithm
        while (slow != fast) {
            slow = arr[slow];
            fast = arr[arr[fast]];
        }
        
        // PHASE 2: Find the starting point of the cycle.
        // Move slow to the beginning (index 0) and advance both slow and fast one step at a time. Their meeting point is the duplicate number.
        fast = 0;
        while (slow != fast) {
            slow = arr[slow];
            fast = arr[fast];
        }
        
        return slow; // both meet at the repeating element
    }
}

/*
    This algorithm relies on the pigeonhole principle and the problem’s strict constraints:

        - The array length is (n + 1)
        - Every value is in the range [1..n]

    Since there are n possible values but (n + 1) positions filled with values from 1..n,
    at least one value MUST appear more than once — duplication is mathematically guaranteed.
    This guarantee is crucial because Floyd’s cycle detection works only if a cycle exists.

    Two different indices have same value → a repeated value causes two different indices to point to the same spot  → loop.

    Without these constraints:
        - No duplicate may exist → no cycle → slow and fast would never meet,
          causing an infinite loop.
        - A value outside the range [1..n] could also lead to out-of-bounds indexing.
*/
