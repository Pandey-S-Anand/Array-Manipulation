//Bruteforce approach

class Solution {
    public static int[] getAnswer(int[] ratings) {
        // Stores: playerRating → total matches played by this player
        Map<Integer, Integer> matchesPlayed = new HashMap<>();

        // Players currently participating in this round
        List<Integer> currentRound = new ArrayList<>();

        // Initialize players and set initial match count to zero
        for (int rating : ratings) {
            currentRound.add(rating);
            matchesPlayed.put(rating, 0);
        }

        // Keep running rounds until only one player remains
        while (currentRound.size() > 1) {
            // Winners (or lone survivors) advance to this list
            List<Integer> nextRound = new ArrayList<>();

            // Process players in pairs
            for (int i = 0; i < currentRound.size(); i += 2) {
                // If there's an odd player out, send them directly to the next round
                if (i + 1 == currentRound.size()) {
                    nextRound.add(currentRound.get(i));
                } else {
                    // Match between two players
                    int player1 = currentRound.get(i);
                    int player2 = currentRound.get(i + 1);

                    // Both players played one match
                    matchesPlayed.put(player1, matchesPlayed.get(player1) + 1);
                    matchesPlayed.put(player2, matchesPlayed.get(player2) + 1);

                    // Higher-rated player wins and moves forward
                    int winner = Math.max(player1, player2);
                    nextRound.add(winner);
                }
            }

            // Move to the next round
            List<Integer> temp = currentRound;
            currentRound = nextRound;
            nextRound = temp;
        }

        // Convert final map values into output array
        for (int i = 0; i < ratings.length; i++) {
            ratings[i] = matchesPlayed.get(ratings[i]);
        }

        return ratings;
    }
}



//Better Approach

class Solution {
    public static int[] getAnswer(int[] ratings) {
        // Maps each player's rating to their original position in the input.
        Map<Integer, Integer> ratingIndexMap = new HashMap<>();

        // Players in the ongoing round.
        List<Integer> currentRound = new ArrayList<>();

        /**
         * Tournament initialization:
         * - Add all players to the first round.
         * - Record each rating’s original index.
         * - Reset the ratings[] array to store match counts.
         */
        for (int i = 0; i < ratings.length; i++) {
            currentRound.add(ratings[i]);
            ratingIndexMap.put(ratings[i], i);
            ratings[i] = 0; // reused as match counter
        }

        while (currentRound.size() > 1) {
            // Stores winners (and auto-advancing odd players) for the next round.
            List<Integer> nextRound = new ArrayList<>();

            for (int i = 0; i < currentRound.size(); i += 2) {

                // Auto-advance if there is no opponent
                if (i + 1 == currentRound.size()) {
                    nextRound.add(currentRound.get(i));
                } else {
                    int player1 = currentRound.get(i);
                    int player2 = currentRound.get(i + 1);

                    // Increment match count for both players
                    ratings[ratingIndexMap.get(player1)]++;
                    ratings[ratingIndexMap.get(player2)]++;

                    // Winner moves to the next round
                    nextRound.add(Math.max(player1, player2));
                }
            }

            // Prepare for further rounds
            List<Integer> temp = currentRound;
            currentRound = nextRound;
            nextRound = temp;
        }

        // Array now contains match counts aligned to original input positions
        return ratings;
    }
}



//Optimal approach


class Solution {
    public static int[] getAnswer(int[] ratings) {
        // Stores total matches played by each player (indexed by original position)
        int[] matchCount = new int[ratings.length];

        // Maps rating → original index for constant-time match count updates
        Map<Integer, Integer> ratingToIndex = new HashMap<>();
        for (int i = 0; i < ratings.length; i++) {
            ratingToIndex.put(ratings[i], i);
        }

        // Use ratings array directly as the current tournament round
        int[] currentRound = ratings;
        int[] nextRound = new int[ratings.length];

        // Tracks how many players are currently active in this round
        int roundSize = ratings.length;

        while (roundSize > 1) {
            int idx = 0; // counts how many players have been placed in nextRound

            for (int i = 0; i < roundSize; i += 2) {
                // If the last player is unpaired → auto-advance
                if (i + 1 == roundSize) {
                    nextRound[idx++] = currentRound[i];
                } else {
                    int playerA = currentRound[i];
                    int playerB = currentRound[i + 1];

                    // Both players participated in this match
                    matchCount[ratingToIndex.get(playerA)]++;
                    matchCount[ratingToIndex.get(playerB)]++;

                    // Higher-rated player moves to next round
                    nextRound[idx++] = Math.max(playerA, playerB);
                }
            }

            int[] temp = currentRound;
            currentRound = nextRound;
            nextRound = temp;
            roundSize = idx;
        }

        return matchCount;
    }
}
