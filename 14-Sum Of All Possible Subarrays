//Bruteforce Approach

class Solution {
    public int subarraySum(int[] arr) {
        int totalSum = 0;

        for (int start = 0; start < arr.length; start++) {
            for (int end = start; end < arr.length; end++) {
                for (int range = start; range <= end; range++) {
                    totalSum += arr[range];
                }
            }
        }

        return totalSum;
    }
}


//Better Approach

class Solution {
    public int subarraySum(int[] arr) {
        int totalSum = 0;

        for (int start = 0; start < arr.length; start++) {
            int subArraySum = 0;
            for (int end = start; end < arr.length; end++) {
                subArraySum += arr[end];
                totalSum += subArraySum;
            }
        }

        return totalSum;
    }
}


//Optimal Approach

class Solution {
    public int subarraySum(int[] arr) {
        int totalSum = 0;

        for (int i = 0; i < arr.length; i++) {
            totalSum += arr[i] * (arr.length - i) * (i + 1);
        }

        return totalSum;

    }
}

/*
 Intuition behind the formula: arr[i] * (i + 1) * (n - i)

 Goal:
 Compute the sum of all subarray sums without generating subarrays explicitly.

 Key idea:
 Instead of summing every subarray, calculate how much each element contributes
 to the final result.

 For a fixed element arr[i]:  we need to count how many subarrays include arr[i].

 How many subarrays include arr[i]?

 A subarray is defined by a start index and an end index.
 For arr[i] to be part of a subarray, BOTH of the following must be true:
     start <= i <= end

 1) Start index choices:
    The subarray can start at any index from 0 to i (inclusive).
    These are the only valid start positions for which a subarray can
    possibly include arr[i], giving (i + 1) possible starting positions.

 2) End index choices:
    The subarray can end at any index from i to n - 1 (inclusive).
    End positions before i are not allowed, because such subarrays
    would end before reaching arr[i], giving (n - i) possible ending positions.


 Therefore, the total number of subarrays that include arr[i] is:
     totalSubarrays = (i + 1) * (n - i)

 Contribution of arr[i] to the total sum:
   = arr[i] * totalSubarrays
   = arr[i] * (i + 1) * (n - i)


Dry run: 

arr[]={1,2,3,4};

All subarrays :

{1} , {1,2}, {1,2,3}, {1,2,3,4}

{2}, {2,3}, {2,3,4}

{3}, {3,4}

{4}

1 Appears 4 times : (n-0) + (n-0)*0

2 Appears 6 times : (n-1) + (n-1)*1

3 Appears 6 times : (n-2) + (n-2)*2

4 Appears 4 times : (n-3) + (n-3)*3

Generalised formula = (n-i)+(n-i)*i
                    = (n-i)*(1+(1*i))
                    = (n-i)*(i+1)
                      
Contribution of each element in total sum is = arr[i] * count of arr[i]
                                             = arr[i] * (n-i)*(i+1)
*/
