//Bruteforce approach

class Solution {
    public List<Integer> findDisappearedNumbers(int[] arr) {
        Arrays.sort(arr);
        List<Integer> notPresent = new ArrayList<>();

        for (int num = 1; num <= arr.length; num++) {
            if (!isPresent(arr, num)) {
                notPresent.add(num);
            }
        }

        return notPresent;
    }

    private boolean isPresent(int[] arr, int key) {
        int low = 0, high = arr.length - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] == key) {
                return true;
            }

            if (key < arr[mid]) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }

        return false;
    }
}


//Good approach

class Solution {
    public List<Integer> findDisappearedNumbers(int[] arr) {
        Set<Integer> presentNumbers = new HashSet<>();
        List<Integer> notPresent = new ArrayList<>();

        for (int num : arr) {
            presentNumbers.add(num);
        }

        for (int num = 1; num <= arr.length; num++) {
            if (!presentNumbers.contains(num)) {
                notPresent.add(num);
            }
        }

        return notPresent;
    }
}


//Better approach

class Solution {
    public List<Integer> findDisappearedNumbers(int[] arr) {
        boolean[] presentNumbers = new boolean[arr.length + 1];
        List<Integer> notPresent = new ArrayList<>();

        for (int num : arr) {
            presentNumbers[num] = true;
        }

        for (int num = 1; num <= arr.length; num++) {
            if (!presentNumbers[num]) {
                notPresent.add(num);
            }
        }

        return notPresent;
    }
}


// Optimal approach

/*
For each value in the array mark its presence by making the number negative at that place in array
eg. if you hae array [3,1,4,1] for 3, i will go to index 2 and make its value negative ie. now nums[2] becomes -4. present array: [3,1,-4,1]
for 1, i will go to index 0 and make its value negative ie. now nums[0] becomes -3. present array: [-3,1,-4,1]
for 4, (take abs value), i will go to index 3 and make its value negative ie. now nums[3] becomes -1. present array: [-3,1,-4,-1]
for 1 take abs value), i will go to index 0 as it is already -ve do nothing. present array: [-3,1,-4,-1]
At last I will have [-3,1,-4,-1]. now i will iterate over the array, whichever idx has positive value that number will not be in the array so as we have nums[1]> 0 so 2 is not in the list.
*/

class Solution {
    public List<Integer> findDisappearedNumbers(int[] arr) {
        List<Integer> notPresent = new ArrayList<>();

        for (int num : arr) {
            int value = Math.abs(num);

            if (arr[value - 1] > 0) {
                arr[value - 1] *= -1;
            }
        }

        for (int i = 0; i < arr.length; i++) {
            if (arr[i] > 0) {
                notPresent.add(i + 1);
            }
        }

        return notPresent;
    }
}
